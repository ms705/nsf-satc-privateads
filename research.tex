\section{Research}
\label{r:stuff}

%
We plan to tackle the problem of privacy-first advertising in two broad steps:
first, we establish the primitives needed to carry out financial accounting in
the ad ecosystem without requiring privacy-invasive data
collection (\S\ref{r:fraud}), and then we address the ad matching process and
hide users' interests and behavior from the other parties in the ecosystem
(\S\ref{r:matching}).
%

\subsection{Preventing abuse when paying for ads, the privacy-preserving way}
\label{r:fraud}

\subsubsection{What we can do based on existing cryptographic algorithms}

\paragraph{Preventing sybils with anonymous credentials.} 
A better approach is when a platform uses anonymous credentials to tell sybils apart from legitimate users.
%
The platform would issue credentials to users who have performed some actions (such as staying on the platform, interacting with it) that increase the platform's trust that these users are humans rather than sybils.  
%
The more such credentials a user's browser has collected, the more evidence the platform has that the user is not a sybil.  

Anonymous credentials~\cite{} can be issued and shown anonymously.
% 
In other words, the issuing party (here, the platform) does not learn anything about the recipient of the credential.
%
A user can subsequently prove possession of his credential(s), without revealing any additional information, and in a way that cannot be linked to the transaction in which the credential(s) was (were) issued.
%
It is possible to limit the number of times an anonymous credential can be shown~\cite{}, so that an adversary cannot perform a sybil attack by simply disseminating the keys necessary for showing these credentials.

\paragraph{First step: user-trusted platform.} Building on existing anonymous credential schemes, we will design a practical end-to-end anonymous authentication protocol. On a high level, we will show how to ensure that a user is not a sybil without revealing their identity to the authentication provider. We assume an identity provider (e.g., Meta) who can be trusted to run infrastructure and to correctly execute the protocols (i.e., honest-but-curious) and users who authenticate from one or more client devices.

Our general approach is based on \emph{anonymous authentication tokens} (AATs) that the authentication provider and clients jointly generate, and which a verifier (who in some settings may be the authentication provider) can verify as genuine without learning the client’s identity. To protect against replay attacks and to limit the usefulness of stolen authentication tokens, each token has a unique serial number and expires after a fixed time. The (single-factor) authentication flow is as follows:
\begin{enumerate}[nosep]
\item The authentication provider orchestrates the protocol for picking the trusted parameters of the system, needed~\cite{lr22} to ensure that the overall system remains secure. Therefore the protocol for picking these parameters must be secure and include trustworthy, non-colluding entities (e.g., EFF, ACLU, other companies).
\item Clients periodically interact with the authentication provider to obtain the credentials they need to generate anonymous authentication tokens. AAT generation might be tied to existing proofs of a non-sybil account with the authentication provider (e.g., some number of friends or established account activity). The underlying cryptographic algorithm may be full-blown anonymous credentials~\cite{EC:camlys01} or anonymous credentials light~\cite{CCS:ballys13}.
\item When a client authenticates to a third-party site, they supply a fresh AAT to the site, which sends it to the authentication provider, who validates it (without learning the client’s identity). If the validation passes, the authentication provider informs the site that a valid user authenticated.
\end{enumerate}

\paragraph{Challenges.} Making this work requires solving both cryptographic challenges and systems ones; here we list some of the research problems that need to be solved:
\begin{itemize}[nosep]
\item The design of the cryptographic protocol for setting up the system, which may require a custom multi-party computation protocol.
\item Adapting existing protocols for obtaining and using tokens; this requires making design choices regarding when tokens are issued, when they expire, whether they are generated locally (with multi-use rate-limited credentials~\cite{chklm06}) or pre-loaded (with anonymous credentials light~\cite{CCS:ballys13}).
\item Addressing systems concerns: what happens if the client’s browser storage is erased and they need new keys? How are keys stored in the browser and protected?
\item Scale: How would a daily issuance of fresh authentication tokens to clients work at the scale of Meta?
%\item Maintaining a database of used-up tokens to prevent token replay.
\end{itemize}


What works currently. %Malte

Explanation of what we propose will happen. %Malte writes up our whiteboard design.

Can use off-the-shelf anonymous credentials light, but they are not concurrently secure. %Anna

Or can use concurrently secure blind sigs, but trust the user to encode the right stuff. %Anna

Can use off-the-shelf heavy-weight anonymous credentials, but they are not as fast as we'd like, and have some features that are not necessary for this application. %Anna

How all this integrates and gives us something new and cool. %Malte

\subsubsection{Crypto open problems}
%Anna

Two big problems: performance and being able to support attributes in a concurrently secure fashion.  Using known techniques can achieve one or the other (the former under not-so-great cryptographic assumptions).

Make ACL concurrently secure.  AKA Concurrent blind signatures with attributes more efficiently.

Take an existing concurrently secure blind sig, for example blind RSA, and explore adding attributes.

Delegation of blind sig issuance capability.

Post-quantum.

\subsubsection{Systems open problems}
% Malte
How to scale using CDNs -- can't just give Akamai your cryptographic keys, need to certify each Akamai server involved. Also dealing with the more expensive crypto operations as part of being a platform/publisher.  Don't want to be orders of magnitude more expensive than today.

On the user side: makes sure that the user's browser is following the correct protocol.

Backwards-compatibility.  Ad delivery should work using existing mechanisms, so no need for a new way to display ads in the browser.
Convey the crypto information in addition to the actual ad, in a way that would work on existing browsers, and without cookies, or at least without identifying cookies.



\subsection{Targeting/bidding}
\label{r:matching}

this part is significantly harder.  Assumptions about user interest categories.

Validation schemes between publisher, platform and user.  Publisher tries to match ads to user interests.  Platform verifies (for a small sample of users) the interests as presented by the publisher against the user's browser history, and has a way to score whether the publisher is good at matching users with ads.  (Possibly on a per-campaign basis.)

Calculating the conversion rate: how many people clicked on the ad, and also how many then proceeded to buy.

\begin{enumerate}
\item Send multiple ads to browser
\item Browser decides which ad to show based on locally-computed interests
\item If user clicks on the ad, the advertiser finds out
\item To charge correctly, the platform needs to find out, so we need either (1) an incentive for the advertiser to communicate with the platform, or (2) notify the platform about the conversion
\item Multiple possible solutions: advertiser needs to pass conversion token to platform to get information it needs in order to assess effectiveness of campaign; anonymizing proxy between browser and platform to handle conversion notifications
\item All of the messages need to be privacy-preserving as far as the identity of the user is concerned
\end{enumerate}
