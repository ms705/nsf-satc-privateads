\section{Research}
\label{r:stuff}

\paragraph{Design overview.}
%
%When a user lands on an advertiser's website, the advertiser wants two pieces of information: (1) is this a real human, or a sybil? and (2) which ad was effective at sending this user here?
%
%In case this is a real user, the advertiser needs to reward the publisher/platform who showed the ad to the user.
%
%In case the user makes a purchase, the advertiser needs to pay the platform, which rewards the publisher for the success of the ad.
%

\begin{figure}
 \centering
 \todo{add diagram}
 \caption{Overview of our privacy-preserving ad economy design.}
 \label{f:overview}
\end{figure}

%
We now sketch our privacy-preserving ad ecosystem in which the cryptographic protocols combined with the participants' incentives prevent them from cheating (Figure~\ref{f:overview}).
%

%
The platform (\eg Google or Meta) has a notion of active, non-sybil users, established \eg by continued engagement on the platform's services and a plausible usage history that is costly to fake.
%
For each such user, the platform issues their devices with a secret that the browser on the user's device uses to derive \emph{user tokens} at a fixed rate.
%
These user tokens are signed by the platform and certify that the platform knows that the owner is a valid, non-sybil human user, but when verified do not reveal the user's identity.
%
Each ad displayed to a user consumes such a user token.
%
We expect to base the user token generation on existing work on compact tokens (see \S\ref{s:compacttokens}).
%

%
An \textbf{ad interaction} begins with a user visiting web content by the publisher (\eg the New York Times), which embeds ads provided by the platform (\eg Google or Meta).
%
Here, the publisher knows who the user is on their service, but withholds this information from the platform, so the platform can no longer map publisher users (and their behavior) to its own users.
%
The device sends a previously-generated user token to the platform, which now knows that the request comes from a non-sybil user (but not from whom).
%
In response, the platform serves an ad, potentially based on user interests collected locally in the browser, alongside a signed token that certifies that the ad was issued for the publisher, who may later demand payment from the platform.
%
This \emph{ad impression token} consists of a blind signature with attributes $(P, a)$, documenting the identity of the publisher ($P$) and the ad shown ($a$).
%
Here, the platform is the signer and the user is the recipient in the blind signature protocol.
%
The identity of the publisher is a \emph{hidden} attribute, which is important to uphold the publisher's anonymity in the user's following potential interaction with the advertiser.
%

%
The end-user's client browser receives the ad impression token alongside the ad, and embeds the ad in the publisher's content.
%
If the user clicks on the ad, their browser directs them to the advertiser's landing page.
%
However, the browser's request hides the source of the ad impression (\eg the HTTP referrer), so that the publisher remains anonymous to the advertiser.
%
The platform learns nothing about the user's interaction with the ad at this point.
%
Instead, the browser forwards the ad impression token to the advertiser, who verifies that it is signed by the platform and thus must correspond to a non-sybil user's activity.
%
However, the advertiser cannot read the hidden attribute $P$, so the publisher remains anonymous; and the advertiser doesn't yet know the user's identity (as the ad impression token does not include it).
%

%
If the end-user now makes a purchase through the advertiser's website (a ``conversion event''), the advertiser learns their identity.
%
In addition, the advertiser incurs a responsibility to pay the platform, and the platform must pay the publisher.
%
To document this responsibility, the advertiser generates a \emph{conversion token}, a signed message derived from the ad impression token (\eg by hashing it).
%
Again, we use blind signatures to realize this token, and have the advertiser sign it, while the end-user is the recipient and the platform is the verifier.
%
The advertiser sends the conversion token back to the client browser, which now has a token signed by $A$ documenting an ad conversion by a valid, non-sybil user.
%
The end-user's client browser sends this conversion token to the platform, which verifies the advertiser's signature on it.
%
The platform knows at this point that a real user saw a valid ad impression, and that a conversion event involving $A$ happened.
%
Importantly, the platform does not know the user's identity, and although it can map the ad impression to $P$ and the conversion to $A$, neither the publisher nor the advertiser know about each other (recall that $P$ is a hidden attribute of the ad impression token).
%

%
Finally, in response to a verified conversion token, the platform issues an \emph{IOU token} to the client browser and saves the conversion token for future use.
%
The IOU token is a signed statement that the platform has verified the conversion token's signatures, and includes the publisher's identity ($P$) as an attribute.
%
The IOU token constitutes an obligation for the platform to pay $P$ if presented with the token by $P$.
%
The end-user client browser, which locally remembers the ad impression and publisher, sends the IOU token to $P$, who can later redeem it with the platform for payment.
%
When the platform receives the IOU token from a publisher, it verifies its own signature on it, charges the advertiser.
%
To charge the advertiser ($A$), the platform presents the conversion token signed by $A$, and $A$ verifies its signature on it.
%
$A$ pays the platform, which takes its cut, and finally rewards the publisher.
%

%
This design achieves our privacy goals.
%
First, at no point is the platform aware of the user's identity, but it can trust that the user is a real platform user because the original ad impression was conditioned on the user presenting a user token.
%
Second, the user's identity on the platform remains hidden from publisher and advertiser, and the user may be known to the publisher and the advertiser under different identities (\eg a pseudonym with the publisher and their real name and address with the advertiser).
%
Third, the advertiser never finds out the publisher's identity, since it is hidden in the ad impression token and absent from the conversion token, and it never interacts with the publisher directly.
%
Fourth, the publisher never finds out the advertiser's identity, since it only receives IOU tokens from the user that do no mention the advertiser, and never interacts with the advertiser directly.
%
Finally, no party (except the end-user) finds out which specific combination of content, ad, and platform user resulted in a conversion, only that all of them are valid events and users: the platform knows the combination of $(P, a)$, but not which content the publisher embedded the ad in; the user's identity on the platform is always hidden; the advertiser never finds out the identity of the publisher or what content the ad was embedded in; and the publisher never finds out what ad the user saw.
%

%
Next, we describe our research agenda to make this design a reality, and elaborate on the cryptographic and systems challenges we will need to address to achieve this.
%

\subsection{Research Goal 1: Untraceable Cryptographic Tokens}
\label{rg1}

At a minimum, all the tokens generated in our design of the ad economy need to be untraceable.  In other words, the transaction in which the token is issued needs to be unlinkable to the one in which it is ``spent," or shown to a verifier.  The most well-studied cryptographic mechanism for such unlinkable tokens is a blind signature scheme.  

A blind signing protocol is a protocol between a signer and a user in which the user outputs a digital signature on the desired message, while the signer learns nothing about the message or the resulting signature.
A blind signature scheme is a signature scheme that has a blind signing protocol.  In spite of having a relatively long history (they were introduced almost forty years ago by David Chaum~\cite{C:Chaum82}), blind signatures are a subject of excitement in the cryptography research community at the moment because they can be used as privacy-preserving authentication tokens that can replace browser cookies in certain applications, for example by the VPN by Google One~\cite{google-one-vpn} and Apple's iCloud Private Relay~\cite{apple-private-relay}. In the ad ecosystem space, they are part of 
Apple's Safari browser proposal for privacy-preserving click measurements~\cite{safari-clicks}.

The formal definition of security of blind signatures~\cite{JC:PoiSte00,C:JueLubOst97,RSA:AbdNamNev06,JC:SchUnr17} requires two security properties: \emph{blindness} and \emph{one-more unforgeability}. Blindness guarantees that an adversarial signer can neither learn the message in the signing protocol nor link a particular message-signature pair to a protocol execution.  One-more unforgeability guarantees that an adversary cannot produce more signed messages than the number of times it invoked the signing protocol.  

The sheer volume of the tokens being issued in a system of this scale requires that these tokens be concurrently secure (i.e. remain unforgeable in the presence of an adversary that causes several tokens to be concurrently issued to adversarial users). Recently, a devastating attack was discovered~\cite{EC:BLLOR21} on numerous proposed constructions of blind signatures, even those provably unforgeable in the stand-alone or sequential setting~\cite{C:Okamoto92,ICICS:Schnorr01,C:AbeOka00,C:Brands93,paquin2013u-prove,CCS:BalLys13,SP:STVWJG16,cryptoeprint:2017:682,JC:GJKR07}.  This attack makes it clear that, unless a blind signature scheme is proven secure in the concurrent setting, its proof of security is not good enough.

\subsubsection{Concurrently composable blind signature schemes}  
\label{rg1:blindsigs}

Bellare et al.~\cite{JC:BNPS03} gave a blind signature scheme that is concurrently unforgeable under the one-more-RSA assumption; recently, another concurrently secure blind signature scheme was proposed as a standard~\cite{ietf:djw21,ietf:djw22} and shown (by PI Lysyanskaya) to also be unforgeable under the one-more-RSA assumption~\cite{EPRINT:Lysyanskaya22}.  Unfortunately, the one-more-RSA assumption is somewhat non-standard.  Additionally, RSA-based schemes generally require larger public-key and signature sizes than, say, schemes that are based on elliptic curve cryptography.  In the elliptic curve setting, the most efficient schemes are those due to Tessaro and Zhu~\cite{EC:TesZhu22}; unfortunately their proof of security also relies on strong modeling assumptions for the underlying groups, such as the generic group model and the algebraic group model~\cite{C:FucKilLos18,EC:Shoup97}.  In the bilinear pairing setting~\cite{C:BonFra01}, Boldyreva's scheme also provides an efficient concurrently secure blind signature~\cite{PKC:Boldyreva03}, but unfortunately its proof of security relies on the one-more-discrete-logarithm assumption~\cite{C:BelPal02}, which is a non-falsifiable assumption~\cite{C:Naor03}.  

The most efficient concurrently secure blind signature schemes relying on well-understood assumptions such as the standard RSA assumption and the computational Diffie-Hellman assumption in the bilinear setting are due to PI Lysyanskaya~\cite{chllw22}; unfortunately, the signer's computation in these schemes is proportional to the number of concurrent sessions in the system which, for our scenario, is prohibitively high. 
Other techniques include PI Lysyanskaya's work~\cite{chllw22} on a transformation that converts a certain broad class of blind signature schemes~\cite{EC:HauKilLos19} that can tolerate $O(\log n)$ concurrent sessions into schemes that can tolerate $O(n)$ concurrent sessions, but, again, at cost of an $O(n)$-fold increase in computation and an $O(\log n)$-fold increase in communication (building on techniques developed by Katz et al.~\cite{AC:KatLosRos21}).  All these schemes are proven secure in the random-oracle model.

Thus, in spite of its importance, the \textbf{problem of coming up with a practical concurrently composable blind signature scheme based on a well-understood assumption} is an elusive one.  Below are our preliminary ideas for how to tackle it.

\begin{description}
\item[Blind signature from the LRSW assumption] The LRSW assumption was introduced by the PI in 1999~\cite{SAC:lrsw99,lysyan99}, and is by now a fairly established one.  The assumption is that, given a public key $(X,Y)= (g^x,g^y)$ in some group $G$ with generator $g$, and an oracle that, on input $m$, samples a random $a\leftarrow G$ and returns $(a,a^y,a^{x+mxy})$, it hard to produce a tuple $(m^*,a,a^y,a^{x+m^*xy})$ for $m^*\neq 0$ without querying the oracle for $m^*$; under this assumption, a signature on a message $m$ is just one such sample; signature verification requires a bilinear pairing.  A (stand-alone) secure two-party protocol whereby a user receives a signature on his message $m$ while the signer learns nothing about $m$ is already known~\cite{C:CamLys04}.  

Thus, to turn it into a practical concurrently secure blind signature scheme we need to adapt this protocol to ensure that it remains secure under concurrent composition.  This is quite doable: the signer's view can be independent of $m$ (so blindness in the concurrent setting us for free), while the user needs to simply supply some proofs of knowledge of $m$ (and other quantities) that can be carried out in a concurrently secure fashion using the Fischlin compiler~\cite{C:Fischlin05} in the random-oracle model, or using other techniques~\cite{AC:CamDam00,C:CamSho03}. Thanks to the PI's recent work~\cite{lysros22}, not only do we believe that the resulting blind signature can be proven concurrently secure, but it can be proven UC-secure as well. 

\item[Blind signatures from other signatures with efficient protocols]  The above approach can be generalized.  Notice that its starting point was an anonymous credential scheme. To obtain concurrently secure blind signatures from an anonymous credential scheme, the general approach is to (1) make sure that the credential issue protocol is concurrently secure; (2) instead of carrying out a zero-knowledge proof of knowledge of a signature as generally done in the anonymous credentials literature, give the signature in the clear.  Using this approach, we should be able to also obtain concurrently secure blind signatures under the strong Diffie-Hellman assumption~\cite{EPRINT:CamDriLeh16} as well as the strong RSA assumption~\cite{lysyan02a,SCN:CamLys02}.  

We plan to show that this is a successful approach.  However, there is something intellectually unsatisfying about using such a general and computationally involved tool (multi-show anonymous credentials) for the seemingly simpler primitive of a blind signature.  Therefore we expect that the resulting constructions will just be starting points; as we write down their proofs of security we will (we expect) discover that they can be made simpler and more efficient.

\item[Improvements of the generic compiler of~\cite{chllw22}]  A complementary approach is to work on improving the generic compiler of~\cite{chllw22}.  
Currently known compilers are based on the user revealing most of his randomness to the signer to prove honest behavior, and keeping just one out of the $n$ sessions live.  The chances that he sent badly formed messages and was not caught is $1/n$.  But what if we use aggregation somehow, so that he reveals one half of what he is doing, and yet only succeeds in obtaining a signature at the end if he cheats in all of the remaining (unchecked) sessions? Then we obtain a compiler for converting a standalone blind signature into a concurrently secure one.  
\end{description}

Even as we pursue the (more theoretical) directions outlined above, for the purposes of building an initial version of the system as described in Section~\ref{???}, we need to pick an existing blind signature scheme and implement it. The schemes due to Tessaro and Zhu~\cite{EC:TesZhu22} are an attractive choice because they can be efficiently implemented in (standard, pairing-free) elliptic-curve groups, and because they also give an efficient partially blind signature.


\subsubsection{Partially blind signatures}
\label{rg1:partially}



\begin{description}
\item[General transformation from blind signatures] Suppose that we are given a two-round blind signature.  For example, the FDH-RSA-based blind signature of Bellare et al.~\cite{JC:BNPS03} is two-round: in the first round, the user sends $x=H(m)r^e \bmod N$ to the signer (where $m$ is the message, $r$ is a random element of $Z_N^*$, $H$ is hash function modeled as a random oracle, and $(N,e)$ is the signer's RSA public key), and in the second round, the signer responds by providing $y$ such that $y^e=x\bmod N$.  The user derives the signature $s = y/r \bmod N$.  It seems surprising that the signer should be able to embed any information $I$ into the message, since his view is completely independent from this message.  Yet, in our preliminary unpublished work, we have discovered the following simple cut-and-choose transformation from this signature scheme to a partially blind one.  

Suppose the user wants the values $(I,M)$ signed, where $I$ is the part that the signer wants to enforce, while $M$ can be any $\ell$-bit value.  
He picks a random message ID $a$ of length $\ell$.  
For $1\leq i \leq n$, let $m_i = I \circ H(M\circ a \circ i)$.  
The user then picks $r_1,\ldots r_n$ and sends a permutation $\pi$ of the vector $(x_1,\ldots,x_n) = (H(m_1)r_1^e,\ldots H(m_n)r_n^e)$ to the signer; 
i.e., the signer receives $(x'_1,\ldots,x'_n)=(x_{\pi(1)},\ldots,x_{\pi(n)})$.  Next, the signer selects a subset $J$ of $n/2$ indices and asks the user to reveal $r_j$ and $h_j = H(M\circ a \circ \pi(j))$ for $j\in J$.  If for all $j \in J$, $x'_j = H(I \circ h_j)r_j^e$, then  the signer responds with $y$ such that $y^e = \prod_{i\notin J} x'_i$, and the user outputs the signature $\sigma = (J',a,s)$ where $J' = \{j~:~\pi(j)\in J\}$, and $s = y/(\prod_{i \notin J'}r_i)$.  The verification algorithm for this signature scheme accepts the signature $\sigma$ on the pair $(I,M)$ if $s^e = \prod_{i \notin J'} H(I \circ H(M\circ a \circ i))$.  The probability that a malicious user succeeds in getting a signature for and incorrect $I$ is at most $2^{-n/2}$, since this event can only happen if he guesses the set $J$ correctly.  This scheme is a partially blind signature that is one-more-unforgeable under the one-more-RSA assumption, and also satisfies blindness.

It is possible that this result generalizes to Boldyreva's blind signature~\cite{PKC:Boldyreva03}.  We will analyze this compiler more closely and examine whether it (perhaps in a modified form) generalizes to other schemes as well, and how it interacts with other compilers, i.e. whether it's possibly to reduce its overhead when it is executed jointly with, say, the compiler PI Lysyanskaya recently came up with~\cite{chllw22}.

\item[Partially blind signatures using anonymous credentials.] In Section~\ref{rg1:blindsigs}, we gave our preliminary ideas for obtaining new concurrently secure blind signatures by using techniques that the PI developed as part of her work on anonymous credentials.  These techniques are very well suited for partially blind signatures, because the schemes we have in anonymous credentials allow for attributes that can be verified by the signer.
\end{description}

\subsubsection{Blind signatures with attributes}
\label{rg1:attributes}

The problem is that a blind signature scheme is not necessarily enough.  What we need is a blind signature with attributes (explain why). 

\begin{enumerate}
\item Salvaging stuff with Foteini.
\item General tools for making anonymous credential schemes concurrently secure.  
\end{enumerate}

\subsubsection{Compact tokens}
\label{rg1:compact}


\subsection{Research Goal 2: Systems Design for Private Advertising}

\subsection{Research Goal 3: Scalable Private Advertising}

\subsection{Preventing sybils with anonymous credentials} 
%A better approach is when a platform uses anonymous credentials to tell sybils apart from legitimate users.
%
Suppose that the platform issues credentials to users who have performed some actions (such as staying on the platform, interacting with it) that increase the platform's trust that these users are humans rather than sybils.  
%
The more such credentials a user's browser has collected, the more evidence the platform has that the user is not a sybil.  

Anonymous credentials~\cite{} can be issued and shown anonymously.
% 
In other words, the issuing party (here, the platform) does not learn anything about the recipient of the credential.
%
A user can subsequently prove possession of his credential(s), without revealing any additional information, and in a way that cannot be linked to the transaction in which the credential(s) was (were) issued.
%
It is possible to limit the number of times an anonymous credential can be shown~\cite{}, so that an adversary cannot perform a sybil attack by simply disseminating the keys necessary for showing these credentials.

\paragraph{First step: honest-but-curious platform.} Building on existing anonymous credential schemes, we will design a practical end-to-end anonymous authentication protocol. On a high level, we will show how to ensure that a user is not a sybil without revealing their identity to the authentication provider. We assume an identity provider (e.g., Meta) who can be trusted to run infrastructure and to correctly execute the protocols (i.e., honest-but-curious) and users who authenticate from one or more client devices.

Our general approach is based on \emph{anonymous authentication tokens} (AATs) that the authentication provider and clients jointly generate, and which a verifier (who in some settings may be the authentication provider) can verify as genuine without learning the client’s identity. To protect against replay attacks and to limit the usefulness of stolen authentication tokens, each token has a unique serial number and expires after a fixed time. The (single-factor) authentication flow is as follows:
\begin{enumerate}[nosep]
\item The authentication provider orchestrates the protocol for picking the trusted parameters of the system, needed~\cite{lr22} to ensure that the overall system remains secure. Therefore the protocol for picking these parameters must be secure and include trustworthy, non-colluding entities (e.g., EFF, ACLU, other companies).
\item Clients periodically interact with the authentication provider to obtain the credentials they need to generate anonymous authentication tokens. AAT generation might be tied to existing proofs of a non-sybil account with the authentication provider (e.g., some number of friends or established account activity). The underlying cryptographic algorithm may be full-blown anonymous credentials~\cite{EC:camlys01} or anonymous credentials light~\cite{CCS:ballys13}.
\item When a client authenticates to a third-party site, they supply a fresh AAT to the site, which sends it to the authentication provider, who validates it (without learning the client’s identity). If the validation passes, the authentication provider informs the site that a valid user authenticated.
\end{enumerate}

%\paragraph{Challenges.} 
Making this work requires solving both cryptographic challenges and systems ones; here we list some of the research problems that need to be solved:
\begin{itemize}[nosep]
\item The design of the cryptographic protocol for setting up the system, which may require a custom multi-party computation protocol.
\item Adapting existing protocols for obtaining and using tokens; this requires making design choices regarding when tokens are issued, when they expire, whether they are generated locally (with multi-use rate-limited credentials~\cite{chklm06}) or pre-loaded (with anonymous credentials light~\cite{CCS:ballys13}).
\item Addressing systems concerns: what happens if the client’s browser storage is erased and they need new keys? How are keys stored in the browser and protected?
\item Scale: How would a daily issuance of fresh authentication tokens to clients work at the scale of Meta?
%\item Maintaining a database of used-up tokens to prevent token replay.
\end{itemize}


\paragraph{Reducing trust in the platform.}
In the scenario above, a malicious platform can create sybils and charge the advertiser for fraudulent ads.  In order to increase the advertiser's confidence that a user is not a sybil, we can have several platforms grant credentials to a user; thus if the advertiser trusts one of them, that's evidence.  However, which platforms have given a user credentials may reveal information about the user's identity.  Thus we want the user to say "I have AATs from 2 out of 3 platforms, won't tell you which."

\paragraph{Preventing sybils with anonymous credentials} 

%What works currently. %Malte

%Explanation of what we propose will happen. %Malte writes up our whiteboard design.

%Can use off-the-shelf anonymous credentials light, but they are not concurrently secure. %Anna

%Or can use concurrently secure blind sigs, but trust the user to encode the right stuff. %Anna

%Can use off-the-shelf heavy-weight anonymous credentials, but they are not as fast as we'd like, and have some features that are not necessary for this application. %Anna

%How all this integrates and gives us something new and cool. %Malte

\subsubsection{Crypto open problems}
%Anna

Two big problems: performance and being able to support attributes in a concurrently secure fashion.  Using known techniques can achieve one or the other (the former under not-so-great cryptographic assumptions).

Make ACL concurrently secure.  AKA Concurrent blind signatures with attributes more efficiently.

Take an existing concurrently secure blind sig, for example blind RSA, and explore adding attributes.

Delegation of blind sig issuance capability.

Post-quantum.

\subsubsection{Systems open problems}

%
Online advertising operates at huge scale, with platforms serving millions of ad impressions per second, served by distributed systems of hundreds or thousands of servers.
%
Any practical solution to privacy-preserving advertising must therefore be \emph{scalable}, but making the proposed designs scalable requires addressing three challenges: (1) scaling to many servers, (2) the per-request costs imposed by cryptography, and (3) handling untrusted client browsers.
%

%
A classic technique for scaling content delivery on the internet to many (geographically distributed) servers is to use a Content Distribution Network (CDN), such as Cloudflare or Akamai.
%
However, a naive solution where each CDN server has access to the cryptographic material needed is insecure. \todo{can't just give Akamai your cryptographic keys, need to certify each Akamai server involved.}
%

%
Adding cryptography to real-time ad auctions and ad serving logic potentially increases the cost of each request by orders of magnitude---a prohibitive cost for the platform operator (who would have to buy and run many more servers) that would make the design impractical.
%
We plan to solve this problem by basing our protocols on lightweight cryptography that can execute quickly on the server side, and by leveraging offline pre-computation of secrets, such as a daily handshake between the ad platform and a client browser that provides a batch of ad tokens generated efficiently or during periods of low load on the platform (\eg at night).
%
%Also dealing with the more expensive crypto operations as part of being a platform/publisher.  Don't want to be orders of magnitude more expensive than today.

%
On the \emph{client side}, we must ensure that the client device follows the protocols correctly.
%
However, client software (such as browsers and device operating systems) are under the user's control and can be modified with malicious intent (\eg by a click farm operator).
%
We will therefore develop attestation mechanisms that ensure that the user's browser is following the correct protocol, \eg by relying on trusted hardware, such as TPMs and TEEs, that is now commonly available.
%
These hardware extensions can produce a cryptographic proof of the integrity of the running executable, and we imagine that an ad platform would keep a centralized allow-list of approved browser releases.
%

%
Finally, the client-side ad delivery needs to be backwards-compatibile: it should use existing mechanisms, such as embedded images, JavaScript, and HTML iFrames, so browsers can integrate it easily.
%
This requires conveying the cryptographic information needed in addition to the actual ad, in a way that works on existing browsers and without using identifying per-user cookies.
%
For this, we will investigate integrating the cryptographic material in the ad's data itself (\eg image metadata, or HTML code served), or adding minimal extensions to the browser's DOM to convey this additional information in a backwards-compatible way.
%


\subsection{Targeting/bidding}
\label{r:matching}

this part is significantly harder.  Assumptions about user interest categories.

Validation schemes between publisher, platform and user.  Publisher tries to match ads to user interests.  Platform verifies (for a small sample of users) the interests as presented by the publisher against the user's browser history, and has a way to score whether the publisher is good at matching users with ads.  (Possibly on a per-campaign basis.)

Calculating the conversion rate: how many people clicked on the ad, and also how many then proceeded to buy.

\begin{enumerate}
\item Send multiple ads to browser
\item Browser decides which ad to show based on locally-computed interests
\item If user clicks on the ad, the advertiser finds out
\item To charge correctly, the platform needs to find out, so we need either (1) an incentive for the advertiser to communicate with the platform, or (2) notify the platform about the conversion
\item Multiple possible solutions: advertiser needs to pass conversion token to platform to get information it needs in order to assess effectiveness of campaign; anonymizing proxy between browser and platform to handle conversion notifications
\item All of the messages need to be privacy-preserving as far as the identity of the user is concerned
\end{enumerate}
